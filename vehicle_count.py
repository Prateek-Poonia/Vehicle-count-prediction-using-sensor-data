# -*- coding: utf-8 -*-
"""Vehicle_Count.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-U9iA0unZWq3xVHdCdoNViX02Lysp5GA

**Vehicle Count Prediction Using Sensor Data**
"""

import pandas as pd
import numpy as np

#Loading the data
data = pd.read_csv('/content/vehicles2.csv')

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score

# Convert 'Date' column to datetime
data['Date'] = pd.to_datetime(data['Date'])

data['Date'] = data['Date'].astype(np.int64) // 10**9  # Convert to Unix timestamp

x = data[['Date']]
y = data['vehicles']

train_x, test_x, train_y, test_y = train_test_split(x, y, test_size=0.9)

# Initialize StandardScaler
scaler = StandardScaler()

# Fit on training data
scaler.fit(train_x)

# Transform both training and testing features
train_x_scaled = scaler.transform(train_x)
test_x_scaled = scaler.transform(test_x)

# Create and train the regression model
model = LinearRegression()
model.fit(train_x_scaled, train_y)

# Make predictions on the testing set
predictions = model.predict(test_x_scaled)

mse = mean_squared_error(test_y, predictions)

r_squared = r2_score(test_y, predictions)

print(predictions)

print("Mean Squared Error:", mse)
print("R-squared:", r_squared)

from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()

# Fit on training data
scaler.fit(train_x)

# Transform both training and testing features
train_x_scaled = scaler.transform(train_x)
test_x_scaled = scaler.transform(test_x)

# Create and train the regression model
model = LinearRegression()
model.fit(train_x_scaled, train_y)

from sklearn.impute import SimpleImputer
s1=SimpleImputer(strategy="mean")
s1.fit_transform(data)

s2=SimpleImputer(strategy="median")
s2.fit_transform(data)

import numpy as np
import pandas as pd

from sklearn.datasets import load_wine
dataset=load_wine()
x=dataset.data
y=dataset.target

x1 = pd.DataFrame(x)
x1.isnull().sum().sum()
from sklearn.model_selection import train_test_split
train_x, test_x, train_y, test_y = train_test_split(x,y,test_size=0.7)

from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
lda = LinearDiscriminantAnalysis(n_components =1)

train_x_lda = lda.fit_transform(train_x,train_y)
test_x_lda = lda.fit_transform(test_x,test_y)

from sklearn.linear_model import LogisticRegression
lr = LogisticRegression()
lr.fit(train_x_lda,train_y)

train_x_lda_lr = lr.predict(train_x_lda)
test_x_lda_lr = lr.predict(test_x_lda)

from sklearn.metrics import accuracy_score
print("Accuracy of training data",accuracy_score(train_x_lda_lr,train_y))
print("Accuracy of testing data",accuracy_score(test_x_lda_lr,test_y))

import datetime

# Create a datetime object for March 1, 2024
new_date = datetime.datetime(2024, 3, 1)

unix_timestamp = int(new_date.timestamp())

print("Unix timestamp for March 1, 2024:", unix_timestamp)

data.head()

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib import pyplot as plt

print(x.shape)
print(y.shape)

test_y = np.array(test_y)
predictions = np.array(predictions)

print(predictions)

# Plotting actual vs predicted values
plt.figure(figsize=(10, 10))
plt.scatter(test_y, predictions, color='blue', alpha=0.5)
plt.title('Actual vs Predicted')
plt.xlabel('Actual')
plt.ylabel('Predicted')
plt.show()

from sklearn.model_selection import train_test_split
train_x, test_x, train_y, test_y = train_test_split(x,y,test_size=0.8)
from sklearn.preprocessing import StandardScaler
sc = StandardScaler()

train_x.shape

train_x_sc=sc.fit_transform(train_x)
test_x_sc=sc.fit_transform(test_x)

sc.fit(train_x_sc,train_y)

from sklearn.linear_model import LogisticRegression
lr = LogisticRegression()

lr.fit(train_x_sc,train_y)
train_x_sc_lr = lr.predict(train_x_sc)
test_x_sc_lr = lr.predict(test_x_sc)

from sklearn.metrics import accuracy_score
print("Accuracy of training data",accuracy_score(train_x_sc_lr,train_y))
print("Accuracy of testing data",accuracy_score(test_x_sc_lr,test_y))